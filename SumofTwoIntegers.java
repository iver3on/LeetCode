/**
 * 对于二进制的加法运算，若不考虑进位，则1+1=0,1+0=1,0+1=1,0+0=0,通过对比异或，不难发现，此方法与异或运算类似。
 * 因而排出进位，加法可用异或来实现。然后考虑进位，0+0进位为0,1+0进位为1,0+1进位为0，1+1进位为1，该操作与位运算的&操作相似。

　　那么加法运算可以这样实现：

　　1）先不考虑进位，按位计算各位累加（用异或实现），得到值a；

　　2）然后在考虑进位，并将进位的值左移，得值b，若b为0，则a就是加法运算的结果，若b不为0，则a+b即得结果（递归调用该函数）。
 */
/*正好，在位运算中，我们用“<<”表示向左移动一位，也就是“进位”。那么我们就可以得到如下的表达式
//进位可以用如下表示：
(x&y)<<1
到这里，我们基本上拥有了这样两个表达式
x^y //执行加法
(x&y)<<1 //进位操作
我们来做个2位数的加法，在不考虑进位的情况下
11+01 = 100  // 本来的算法
 
// 用推算的表达式计算
11 ^ 01 = 10
 
(11 & 01) << 1 = 10
 
//到这里 我们用普通的加法去运算这两个数的时候就可以得到 10 + 10 = 100
//但是我们不需要加法，所以要想别的方法，如果让两个数再按刚才的算法计算一次呢
 
10 ^ 10 = 00
 
(10 & 10) << 1 = 100
到这里基本上就得出结论了，其实后面的那个 “00” 已经不用再去计算了，因为第一个表达式就已经算出了结果。
继续推理可以得出三位数的加法只需重复的计算三次得到第一个表达式的值就是计算出来的结果。
 * 
 * 
 */
package leetcode;

/**
 * @author Iver3on
 * @date 2016年8月28日
 */
public class SumofTwoIntegers {

	/**
	 * 
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println(bitAdd(1, 2));
	}

	static int bitAdd(int a, int b) {
		if (b == 0)
			return a;
		int sum = a ^ b;
		int carry = (a & b) << 1;
		return bitAdd(sum, carry);
	}
}
